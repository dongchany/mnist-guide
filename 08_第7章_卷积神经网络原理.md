# 第 7 章：图像与卷积——让网络学会"看"

> **本章目标**：理解卷积、滤波器、池化的原理，知道 CNN 为什么适合处理图像。
> **预计时间**：2.5 小时

---

## 7.1 全连接网络的问题

上一章的 FC 网络把图片展平成 784 维向量，丢失了**空间结构**。它不知道像素 (3,5) 和 (3,6) 是相邻的。

另外，FC 对位置很敏感——如果数字"1"稍微左移几个像素，激活模式就完全不同了。

CNN 用两个关键思想解决这些问题：**局部连接**和**参数共享**。

---

## 7.2 直觉：卷积 = 滑动的特征检测器

想象你有一个 3×3 的小"窗口"（叫做**滤波器**或**卷积核**），它在整张图片上滑动。每到一个位置，就把窗口内的像素和滤波器的权重做逐元素相乘再求和。

```
输入图片（5×5）         滤波器（3×3）          输出（3×3）
┌─────────────┐      ┌─────────┐        ┌─────────┐
│ 1 0 1 0 1   │      │ 1  0  1 │        │ ?  ?  ? │
│ 0 1 0 1 0   │  *   │ 0  1  0 │   →    │ ?  ?  ? │
│ 1 0 1 0 1   │      │ 1  0  1 │        │ ?  ?  ? │
│ 0 1 0 1 0   │      └─────────┘        └─────────┘
│ 1 0 1 0 1   │
└─────────────┘
```

左上角的计算：

```
1×1 + 0×0 + 1×1 +
0×0 + 1×1 + 0×0 +
1×1 + 0×0 + 1×1  = 5
```

**关键思想**：同一个滤波器在所有位置共享权重。这意味着：
- **参数少**：一个 3×3 滤波器只有 9 个参数，不管图片多大
- **平移不变性**：不管特征出现在哪里，同一个滤波器都能检测到

---

## 7.3 滤波器能检测什么？

不同的滤波器权重对应不同的特征：

```
水平边缘检测器:        垂直边缘检测器:        对角线检测器:
┌──────────┐          ┌──────────┐          ┌──────────┐
│ -1 -1 -1 │          │ -1  0  1 │          │  1  0 -1 │
│  0  0  0 │          │ -1  0  1 │          │  0  1  0 │
│  1  1  1 │          │ -1  0  1 │          │ -1  0  1 │
└──────────┘          └──────────┘          └──────────┘
```

CNN 的魔力在于：这些滤波器**不需要人工设计**，网络通过训练自己学习。

---

## 7.4 数学：卷积运算

给定：
- 输入 X: shape (N, C_in, H, W) — N 个样本，C_in 个通道，高 H，宽 W
- 滤波器 W: shape (C_out, C_in, kh, kw) — C_out 个滤波器，每个 kh×kw
- 偏置 b: shape (C_out,)

输出的每个元素：

```
Output[n, f, i, j] = Σ_c Σ_p Σ_q  X[n, c, i+p, j+q] · W[f, c, p, q]  +  b[f]
```

**Padding**（填充）：在输入边缘填 0，使输出尺寸等于输入尺寸。padding=1 配合 3×3 滤波器，输出和输入尺寸一样。

输出尺寸公式：`out_h = (H + 2·pad - kh) / stride + 1`

---

## 7.5 im2col 技巧：让卷积变成矩阵乘法

直接用四重循环做卷积太慢了。**im2col**（image to column）是一个巧妙的技巧——把卷积运算转化为矩阵乘法。

**思路**：把输入图片中每个"感受野"（滤波器覆盖的区域）拉成一行，拼成一个大矩阵。然后把滤波器也拉平，做一次矩阵乘法就完成了所有位置的卷积。

```
原始做法（慢）:           im2col 做法（快）:
for each position:       col = im2col(X)        # (N·oh·ow, C·kh·kw)
    extract patch        W_flat = W.reshape(...)  # (C·kh·kw, C_out)
    dot with filter      output = col @ W_flat    # one matrix multiply!
```

```python
def im2col(X, kh, kw, stride=1, pad=0):
    """Transform input into column matrix for efficient convolution."""
    N, C, H, W = X.shape
    if pad > 0:
        X = np.pad(X, ((0,0),(0,0),(pad,pad),(pad,pad)), mode='constant')
        _, _, H, W = X.shape
    
    out_h = (H - kh) // stride + 1
    out_w = (W - kw) // stride + 1
    
    col = np.zeros((N, C, kh, kw, out_h, out_w))
    for i in range(kh):
        for j in range(kw):
            col[:, :, i, j] = X[:, :, i:i+stride*out_h:stride, j:j+stride*out_w:stride]
    
    # Reshape to (N*out_h*out_w, C*kh*kw)
    return col.transpose(0,4,5,1,2,3).reshape(N * out_h * out_w, -1), out_h, out_w
```

---

## 7.6 最大池化（Max Pooling）

池化层的作用：**降低空间分辨率**，减少参数，同时增加一点平移不变性。

最常用的是 2×2 最大池化，步长为 2：

```
输入 (4×4):            输出 (2×2):
┌─────────────┐       ┌──────┐
│ 1  3 │ 2  1 │       │ 3  2 │    ← max of each 2×2 block
│ 0  2 │ 1  0 │   →   │ 4  3 │
├──────┼──────┤       └──────┘
│ 4  1 │ 3  2 │
│ 0  1 │ 1  0 │
└─────────────┘
```

每个 2×2 区域取最大值。空间尺寸减半。

---

## 7.7 CNN 的整体架构

我们的 mini CNN：

```
Input (1, 28, 28)
    │
    ▼
Conv1: 4 filters 3×3, pad=1  →  (4, 28, 28)   ← 学习 4 种特征
ReLU                          →  (4, 28, 28)
MaxPool 2×2                   →  (4, 14, 14)   ← 空间减半
    │
    ▼
Conv2: 8 filters 3×3, pad=1  →  (8, 14, 14)   ← 组合成 8 种更复杂的特征
ReLU                          →  (8, 14, 14)
MaxPool 2×2                   →  (8, 7, 7)     ← 再次减半
    │
    ▼
Flatten                       →  (392,)        ← 8×7×7 = 392
FC1 + ReLU                    →  (32,)
FC2 + Softmax                 →  (10,)         ← 10 个类别的概率
```

**参数量**：只有约 13,000 个，比 FC 网络的 52,650 少很多，但效果更好（因为利用了空间结构）。

---

## 7.8 卷积层的反向传播

卷积层的梯度推导和 im2col 是对称的。因为前向是 `col @ W_flat`，所以：

```
∂L/∂W_flat = colᵀ @ ∂L/∂output
∂L/∂col   = ∂L/∂output @ W_flatᵀ
```

然后需要把 ∂L/∂col "折回"成 ∂L/∂X 的形状（col2im，im2col 的逆操作）。

池化层的反向传播更简单：梯度只流向前向传播时取到最大值的那个位置，其他位置梯度为 0。

具体代码实现在下一章。

---

## 7.9 动手练习

**练习 1**：手动计算——给定 3×3 输入和 2×2 滤波器（无 padding，stride=1），计算输出。

**练习 2**：对一张 MNIST 图片分别应用水平和垂直边缘检测滤波器，用 matplotlib 显示结果。

**练习 3**：计算我们的 CNN 每一层的输出尺寸和参数量。
